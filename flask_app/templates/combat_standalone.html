{% extends "base.html" %}

{% block title %}Combat - Mass Gravity{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/space-animations.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/combat.css') }}">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
    
<!-- Socket.IO Client -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.js"></script>

<!-- Three.js - all in one file with full compatibility -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
{% endblock %}

{% block content %}
<!-- Space background -->
<div class="space-background">
    <div class="nebula-background"></div>
    <div class="stars"></div>
    <div class="stars"></div>
</div>

<div id="resource-display">
    <div class="resource-item">
        <i class="fas fa-space-shuttle"></i>
        <span id="fighters-value">0</span> Fighters
    </div>
    <div class="resource-item">
        <i class="fas fa-rocket"></i>
        <span id="capital-ships-value">0</span> Capital Ships
    </div>
    <a href="{{ url_for('main.build') }}" class="resource-item" style="margin-left: auto;">
        <i class="fas fa-arrow-left"></i> Return to Galaxy
    </a>
</div>

<div class="battle-status">
    <h3>Battle Status</h3>
    <div id="opponent-info">
        Opponent: <span id="opponent-name">Connecting...</span>
    </div>
    <div id="battle-info">
        Status: <span id="battle-status-text">Waiting for opponent</span>
    </div>
</div>

<div id="combat-container"></div>

<!-- Removed combat UI menu as requested -->

<div id="waiting-overlay" class="waiting-overlay">
    <h2 class="pulse-glow">Waiting for opponent to accept battle...</h2>
    <p>Once accepted, the battle will begin.</p>
    <button id="cancel-battle" class="combat-button" style="margin-top: 30px;">Cancel</button>
</div>

<!-- Connection status indicator -->
<div id="connection-status" class="connecting">
    <div class="indicator"></div>
    <span>Connecting...</span>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Store user info
    window.USER_INFO = {
        id: {{ current_user.id }},
        username: "{{ current_user.username }}",
        faction: "{{ current_user.faction }}",
        ships: {
            fighters: 5,
            capital_ships: 1
        }
    };
    
    // Store opponent ID
    window.OPPONENT_ID = {{ opponent_id }};
    
    // Set up Socket.IO connection
    const socket = io();
    
    // Connection status handlers
    socket.on('connect', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'connected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Connected</span>';
        console.log('Socket connected');
        
        // Join combat room
        socket.emit('join_combat', {
            opponent_id: window.OPPONENT_ID,
            user_id: window.USER_INFO.id,
            username: window.USER_INFO.username
        });
    });
    
    socket.on('disconnect', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'disconnected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Disconnected</span>';
        console.log('Socket disconnected');
    });
    
    socket.on('connect_error', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'disconnected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Connection Error</span>';
        console.log('Socket connection error');
    });
    
    // Combat specific socket handlers
    socket.on('battle_accepted', function(data) {
        console.log('Battle accepted event received:', data);
        // Hide waiting overlay, battle is starting
        document.getElementById('waiting-overlay').style.display = 'none';
        
        // Update battle info
        document.getElementById('opponent-name').textContent = data.opponent_name;
        document.getElementById('battle-status-text').textContent = 'Battle in progress';
        
        // Initialize the combat game
        const game = initializeCombatGame({
            battle_room: data.battle_room,
            opponent_id: window.OPPONENT_ID,
            opponent_name: data.opponent_name,
            opponent_faction: data.opponent_faction,
            ships: window.USER_INFO.ships,
            opponent_ships: data.opponent_ships || { fighters: 5, capital_ships: 1 }
        });
        
        // Set up opponent ship movement handler with debug output
        socket.on('opponent_move', function(moveData) {
            console.log('Received opponent_move event:', moveData);
            if (game && typeof game.handleOpponentMove === 'function') {
                game.handleOpponentMove(moveData);
            } else {
                console.error('Game or handleOpponentMove function not available');
            }
        });
        
        // Confirm readiness to opponent after a short delay
        setTimeout(function() {
            socket.emit('combat_ready', {
                battle_room: data.battle_room,
                user_id: window.USER_INFO.id
            });
            console.log('Sent combat_ready event');
        }, 1000);
    });
    
    socket.on('opponent_ready', function(data) {
        console.log('Opponent is ready for combat:', data);
        // Update status text
        document.getElementById('battle-status-text').textContent = 'Opponent ready, battle in progress';
    });
    
    socket.on('combat_synchronized', function(data) {
        console.log('Combat fully synchronized, both players ready:', data);
        // Update status text
        document.getElementById('battle-status-text').textContent = 'Battle in progress';
        
        // If the overlay is somehow still visible, hide it
        document.getElementById('waiting-overlay').style.display = 'none';
    });
    
    socket.on('battle_cancelled', function() {
        // Return to the main game
        window.location.href = "{{ url_for('main.build') }}";
    });
    
    // Cancel button handler
    document.getElementById('cancel-battle').addEventListener('click', function() {
        socket.emit('cancel_battle', {
            opponent_id: window.OPPONENT_ID
        });
        
        // Return to the main game
        window.location.href = "{{ url_for('main.build') }}";
    });
    
    // Utility function to show notifications
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = 'notification ' + (type === 'error' ? 'error' : '');
        
        // Add icon based on notification type
        const icon = type === 'error' ? 
            '<i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>' : 
            '<i class="fas fa-info-circle" style="margin-right: 8px;"></i>';
            
        notification.innerHTML = icon + message;
        
        // Set background color based on type
        if (type === 'error') {
            notification.style.backgroundColor = 'rgba(231, 76, 60, 0.8)';
            notification.style.borderColor = 'rgba(231, 76, 60, 0.9)';
        } else {
            notification.style.backgroundColor = 'rgba(46, 204, 113, 0.8)';
            notification.style.borderColor = 'rgba(46, 204, 113, 0.9)';
        }
        
        notification.style.position = 'absolute';
        notification.style.top = '70px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '1000';
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 3000);
    }
    
    // Handle combat timeout
    socket.on('combat_timeout', function(data) {
        console.warn('Combat initialization timeout:', data);
        showNotification('Battle initialization timed out. Please try again.', 'error');
        
        // Redirect back to game after a short delay
        setTimeout(() => {
            window.location.href = "{{ url_for('main.build') }}";
        }, 3000);
    });
    
    // EMBEDDED COMBAT GAME CODE
    // CombatGame class to handle RTS gameplay
    class CombatGame {
        constructor(data) {
            console.log('CombatGame constructor called with data:', data);
            this.data = data;
            this.ships = [];
            this.opponentShips = [];
            this.selectedShips = [];
            this.isAttackMode = false;
            
            // Track mouse position for movement commands
            this.mouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            
            // Connection to server
            this.socket = window.socket;
            
            // Store battle info
            this.battleRoom = data.battle_room;
            this.opponentId = data.opponent_id;
            
            // Start the game setup
            this.init();
        }
        
        init() {
            console.log('Initializing combat game components');
            // Initialize game components
            this.initRenderer();
            this.initScene();
            this.initCamera();
            
            // Set up clock for animations
            this.clock = new THREE.Clock();
            
            this.initLights();
            this.initGridPlane();
            this.initShips();
            this.initEventListeners();
            
            console.log('Combat initialization complete');
            console.log('Ships created:', this.ships.length, 'player ships,', this.opponentShips.length, 'opponent ships');
            console.log('Camera position:', this.camera.position);
            
            // Start game loop
            this.animate();
            
            // Update ship counts
            this.updateShipCounts();
        }
        
        initRenderer() {
            // Create renderer with anti-aliasing for smoother edges
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true  // Allow transparent background
            });
            
            // Set size to match container
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(window.devicePixelRatio); // For sharper rendering
            
            // Enable shadows for realistic lighting
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            
            // Set background color - very dark blue for space
            this.renderer.setClearColor(0x000a1a, 1);
            
            // Add renderer to the DOM
            const container = document.getElementById('combat-container');
            container.innerHTML = ''; // Clear container if it has any content
            container.appendChild(this.renderer.domElement);
            
            console.log('Renderer initialized and added to DOM');
        }
        
        initScene() {
            this.scene = new THREE.Scene();
            
            // Add fog for depth perception but less dense
            this.scene.fog = new THREE.FogExp2(0x0a0f18, 0.001);
            
            // Add a basic skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterial = new THREE.MeshBasicMaterial({
                color: 0x000810,
                side: THREE.BackSide // Render on inside faces
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            this.scene.add(skybox);
            
            // Add some distant stars as points
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 5000; i++) {
                const x = THREE.Math.randFloatSpread(1000);
                const y = THREE.Math.randFloatSpread(1000);
                const z = THREE.Math.randFloatSpread(1000);
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            this.scene.add(stars);
            
            console.log('Scene initialized with skybox and stars');
        }
        
        initCamera() {
            this.camera = new THREE.PerspectiveCamera(
                45, 
                window.innerWidth / window.innerHeight, 
                1, 
                10000
            );
            
            // Set initial camera position - higher for a strategic view, but closer
            this.camera.position.set(0, 150, 200);
            this.camera.lookAt(0, 0, 0);
            console.log('Camera initialized:', this.camera.position);
            
            // We don't use OrbitControls - just implement basic manual camera movement
            this.initBasicCameraControls();
        }
        
        initBasicCameraControls() {
            // Add keyboard controls for camera
            window.addEventListener('keydown', (event) => {
                // Simple keyboard camera controls
                const moveSpeed = 10;
                
                switch(event.key) {
                    case 'ArrowUp': // Move camera up
                        this.camera.position.y += moveSpeed;
                        break;
                    case 'ArrowDown': // Move camera down
                        this.camera.position.y -= moveSpeed;
                        break;
                    case 'ArrowLeft': // Move camera left
                        this.camera.position.x -= moveSpeed;
                        break;
                    case 'ArrowRight': // Move camera right
                        this.camera.position.x += moveSpeed;
                        break;
                    case '+': // Zoom in
                    case '=':
                        this.camera.position.z -= moveSpeed;
                        break;
                    case '-': // Zoom out
                        this.camera.position.z += moveSpeed;
                        break;
                }
                
                // Keep camera looking at center
                this.camera.lookAt(0, 0, 0);
            });
            
            console.log('Basic camera controls initialized - use arrow keys to move, +/- to zoom');
        }
        
        initLights() {
            // Main directional light (like sun)
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);  // Brighter
            mainLight.position.set(100, 200, 100);
            mainLight.castShadow = true;
            
            // Configure shadow properties
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 500;
            mainLight.shadow.camera.left = -200;
            mainLight.shadow.camera.right = 200;
            mainLight.shadow.camera.top = 200;
            mainLight.shadow.camera.bottom = -200;
            
            this.scene.add(mainLight);
            
            // Ambient light (to prevent total darkness in shadows)
            const ambientLight = new THREE.AmbientLight(0x333366, 0.5);  // Brighter blue ambient
            this.scene.add(ambientLight);
            
            // Hemisphere light for better color variation (sky/ground)
            const hemisphereLight = new THREE.HemisphereLight(0xbbddff, 0x102040, 0.7);  // Brighter
            this.scene.add(hemisphereLight);
            
            // Add a rim light to help silhouette the ships
            const rimLight = new THREE.DirectionalLight(0x0088ff, 0.8);
            rimLight.position.set(-100, 50, -100);
            this.scene.add(rimLight);
            
            console.log('Lights initialized');
        }
        
        initGridPlane() {
            // Create a grid for the battle arena - smaller size for better visibility
            const gridSize = 600;
            const gridDivisions = 60;
            const grid = new THREE.GridHelper(gridSize, gridDivisions, 0x00aaff, 0x003366);
            grid.position.y = 0.1; // Slight elevation to avoid z-fighting
            this.scene.add(grid);
            console.log('Grid added to scene');
            
            // Add a translucent plane for shadow casting
            const planeGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
            const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0x001a66,
                transparent: true,
                opacity: 0.4,  // More opacity for better visibility
                roughness: 0.7,
                metalness: 0.3
            });
            
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            plane.userData.isGround = true;
            this.scene.add(plane);
            console.log('Ground plane added to scene');
            
            // Add outer boundary markers for the arena
            const boundaryGeo = new THREE.BoxGeometry(gridSize, 2, 2);
            const boundaryMat = new THREE.MeshLambertMaterial({ 
                color: 0x0088ff,
                emissive: 0x003366
            });
            
            const boundaries = [];
            
            // North boundary
            const northBoundary = new THREE.Mesh(boundaryGeo, boundaryMat);
            northBoundary.position.set(0, 1, -gridSize/2);
            boundaries.push(northBoundary);
            
            // South boundary
            const southBoundary = new THREE.Mesh(boundaryGeo, boundaryMat);
            southBoundary.position.set(0, 1, gridSize/2);
            boundaries.push(southBoundary);
            
            // East boundary
            const eastBoundary = new THREE.Mesh(boundaryGeo, boundaryMat);
            eastBoundary.rotation.y = Math.PI / 2;
            eastBoundary.position.set(gridSize/2, 1, 0);
            boundaries.push(eastBoundary);
            
            // West boundary
            const westBoundary = new THREE.Mesh(boundaryGeo, boundaryMat);
            westBoundary.rotation.y = Math.PI / 2;
            westBoundary.position.set(-gridSize/2, 1, 0);
            boundaries.push(westBoundary);
            
            boundaries.forEach(boundary => {
                this.scene.add(boundary);
            });
        }
        
        initShips() {
            console.log("Initializing ships with player ID:", window.USER_INFO.id);
            console.log("Opponent ID:", this.opponentId);
            
            // Create player ships and opponent ships
            this.createPlayerShips();
            this.createOpponentShips();
            
            // Log all ships with their IDs for debugging
            console.log("Player ships:", this.ships.map(s => s.userData.id));
            console.log("Opponent ships:", this.opponentShips.map(s => s.userData.id));
        }
        
        createPlayerShips() {
            // Get ship counts from data
            const fighters = this.data.ships?.fighters || 5; // Default to 5 if none
            const capitalShips = this.data.ships?.capital_ships || 1; // Default to 1 if none
            
            console.log(`Creating ${fighters} fighters and ${capitalShips} capital ships for player`);
            
            // Player faction color
            const factionColor = this.getFactionColor(window.USER_INFO.faction);
            
            // Create fighter ships in a formation
            for (let i = 0; i < fighters; i++) {
                const fighter = this.createFighterShip(factionColor);
                
                // Calculate position in a neat formation
                const row = Math.floor(i / 3);
                const col = i % 3;
                
                fighter.position.set(
                    -150 - (col * 20), // Left side of the map in columns
                    10, // Slight elevation
                    -50 + (row * 20) // Formation rows
                );
                
                // Create a unique ID that includes the player's user ID
                fighter.userData.id = `player_${window.USER_INFO.id}_fighter_${i}`;
                fighter.userData.type = 'fighter';
                fighter.userData.isPlayerShip = true;
                fighter.userData.health = 2;
                fighter.userData.speed = 0.8;
                fighter.userData.attackPower = 1;
                fighter.userData.isMoving = false;
                fighter.userData.targetPosition = null;
                
                this.ships.push(fighter);
                this.scene.add(fighter);
            }
            
            // Create capital ships
            for (let i = 0; i < capitalShips; i++) {
                const capitalShip = this.createCapitalShip(factionColor);
                capitalShip.position.set(
                    -200 - (i * 30), // Left side of the map, behind fighters
                    20, // Higher elevation
                    0 + (i * 30) // Staggered positioning
                );
                // Create a unique ID that includes the player's user ID
                capitalShip.userData.id = `player_${window.USER_INFO.id}_capital_${i}`;
                capitalShip.userData.type = 'capital';
                capitalShip.userData.isPlayerShip = true;
                capitalShip.userData.health = 10;
                capitalShip.userData.speed = 0.3;
                capitalShip.userData.attackPower = 3;
                capitalShip.userData.isMoving = false;
                capitalShip.userData.targetPosition = null;
                
                this.ships.push(capitalShip);
                this.scene.add(capitalShip);
            }
        }
        
        createOpponentShips() {
            // Get ship counts from data
            const fighters = this.data.opponent_ships?.fighters || 5; // Default to 5 if none
            const capitalShips = this.data.opponent_ships?.capital_ships || 1; // Default to 1 if none
            
            console.log(`Creating ${fighters} fighters and ${capitalShips} capital ships for opponent`);
            
            // Opponent faction color
            const factionColor = this.getFactionColor(this.data.opponent_faction || 'red');
            
            // Create fighter ships in a formation
            for (let i = 0; i < fighters; i++) {
                const fighter = this.createFighterShip(factionColor);
                
                // Calculate position in a neat formation
                const row = Math.floor(i / 3);
                const col = i % 3;
                
                fighter.position.set(
                    150 + (col * 20), // Right side of the map in columns
                    10, // Slight elevation
                    -50 + (row * 20) // Formation rows
                );
                
                // Rotate to face player's side
                fighter.rotation.y = Math.PI;
                
                // Create a unique ID that includes the opponent's user ID
                fighter.userData.id = `player_${this.opponentId}_fighter_${i}`;
                fighter.userData.type = 'fighter';
                fighter.userData.isOpponentShip = true;
                fighter.userData.health = 2;
                fighter.userData.speed = 0.8;
                fighter.userData.attackPower = 1;
                
                this.opponentShips.push(fighter);
                this.scene.add(fighter);
            }
            
            // Create capital ships
            for (let i = 0; i < capitalShips; i++) {
                const capitalShip = this.createCapitalShip(factionColor);
                capitalShip.position.set(
                    200 + (i * 30), // Right side of the map, behind fighters
                    20, // Higher elevation
                    0 + (i * 30) // Staggered positioning
                );
                
                // Rotate to face player's side
                capitalShip.rotation.y = Math.PI;
                
                // Create a unique ID that includes the opponent's user ID
                capitalShip.userData.id = `player_${this.opponentId}_capital_${i}`;
                capitalShip.userData.type = 'capital';
                capitalShip.userData.isOpponentShip = true;
                capitalShip.userData.health = 10;
                capitalShip.userData.speed = 0.3;
                capitalShip.userData.attackPower = 3;
                
                this.opponentShips.push(capitalShip);
                this.scene.add(capitalShip);
            }
        }
        
        createFighterShip(color) {
            // Simple fighter ship representation (cube for now, but more distinctive)
            const geometry = new THREE.BoxGeometry(8, 3, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.5  // Brighter emissive for better visibility
            });
            
            const fighter = new THREE.Mesh(geometry, material);
            fighter.castShadow = true;
            fighter.receiveShadow = true;
            
            // Add a position marker below the ship
            const markerGeo = new THREE.CircleGeometry(4, 16);
            const markerMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.rotation.x = -Math.PI / 2;
            marker.position.y = -2;
            fighter.add(marker);
            
            // Add engines glow (small cylinder at the back)
            const engineGeo = new THREE.CylinderGeometry(0.7, 0.5, 1, 8);
            const engineMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.set(-3, 0, 0); // Position at back of ship
            engine.rotation.z = Math.PI / 2;
            fighter.add(engine);
            
            // Add selection indicator (ring that's hidden by default)
            const ringGeo = new THREE.TorusGeometry(5, 0.3, 8, 24);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.7,
                depthTest: false
            });
            
            const selectionRing = new THREE.Mesh(ringGeo, ringMat);
            selectionRing.rotation.x = Math.PI / 2;
            selectionRing.position.y = -2;
            selectionRing.visible = false;
            selectionRing.userData.isSelectionIndicator = true;
            fighter.add(selectionRing);
            
            return fighter;
        }
        
        createCapitalShip(color) {
            // Larger capital ship (cuboid for now, but more distinctive)
            const geometry = new THREE.BoxGeometry(24, 6, 12);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.5  // Brighter emissive for better visibility
            });
            
            const capitalShip = new THREE.Mesh(geometry, material);
            capitalShip.castShadow = true;
            capitalShip.receiveShadow = true;
            
            // Add a position marker below the ship
            const markerGeo = new THREE.CircleGeometry(12, 24);
            const markerMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.rotation.x = -Math.PI / 2;
            marker.position.y = -4;
            capitalShip.add(marker);
            
            // Add engines glow (two cylinders at the back)
            const engineGeo = new THREE.CylinderGeometry(1.2, 1, 1.5, 8);
            const engineMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            
            const engine1 = new THREE.Mesh(engineGeo, engineMat);
            engine1.position.set(-10, 0, -3); // Bottom engine
            engine1.rotation.z = Math.PI / 2;
            capitalShip.add(engine1);
            
            const engine2 = new THREE.Mesh(engineGeo, engineMat);
            engine2.position.set(-10, 0, 3); // Top engine
            engine2.rotation.z = Math.PI / 2;
            capitalShip.add(engine2);
            
            // Add a bridge on top
            const bridgeGeo = new THREE.BoxGeometry(5, 2, 6);
            const bridgeMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.5,
                roughness: 0.5
            });
            
            const bridge = new THREE.Mesh(bridgeGeo, bridgeMat);
            bridge.position.set(5, 3.5, 0); // Position at the front top
            capitalShip.add(bridge);
            
            // Add selection indicator (ring that's hidden by default)
            const ringGeo = new THREE.TorusGeometry(12, 0.4, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.7,
                depthTest: false
            });
            
            const selectionRing = new THREE.Mesh(ringGeo, ringMat);
            selectionRing.rotation.x = Math.PI / 2;
            selectionRing.position.y = -4;
            selectionRing.visible = false;
            selectionRing.userData.isSelectionIndicator = true;
            capitalShip.add(selectionRing);
            
            return capitalShip;
        }
        
        getFactionColor(faction) {
            switch (faction) {
                case 'blue':
                    return 0x3498db;
                case 'red':
                    return 0xe74c3c;
                case 'green':
                    return 0x2ecc71;
                default:
                    return 0xcccccc; // Default gray
            }
        }
        
        initEventListeners() {
            // Window resize handler
            window.addEventListener('resize', this.onWindowResize.bind(this), false);
            
            // Mouse event handlers for ship selection and commands
            this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this), false);
            this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this), false);
            
            // UI button handlers
            const selectAllButton = document.getElementById('select-all');
            if (selectAllButton) {
                selectAllButton.addEventListener('click', () => {
                    this.selectAllShips();
                });
            }
            
            const attackModeButton = document.getElementById('attack-mode');
            if (attackModeButton) {
                attackModeButton.addEventListener('click', () => {
                    this.setAttackMode(true);
                });
            }
            
            const patrolModeButton = document.getElementById('patrol-mode');
            if (patrolModeButton) {
                patrolModeButton.addEventListener('click', () => {
                    this.setPatrolMode(true);
                });
            }
            
            const retreatButton = document.getElementById('retreat');
            if (retreatButton) {
                retreatButton.addEventListener('click', () => {
                    this.retreat();
                });
            }
        }
        
        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse interaction handlers for ship selection and movement
        onMouseDown(event) {
            // Calculate mouse position in normalized device coordinates
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            this.raycaster.setFromCamera(this.mouse, this.camera);
            
            // Find intersected objects
            const intersects = this.raycaster.intersectObjects(this.scene.children, true);
            
            // Variable to track if we hit a player ship
            let hitPlayerShip = false;
            
            // Check for ship selection - find first intersected ship
            for (const intersect of intersects) {
                // Get top level parent object
                let object = intersect.object;
                while (object.parent && object.parent !== this.scene) {
                    object = object.parent;
                }
                
                // Check if it's a player ship
                if (object.userData && object.userData.isPlayerShip) {
                    hitPlayerShip = true;
                    
                    // Check if shift key is pressed for multi-select
                    const isMultiSelect = event.shiftKey;
                    
                    // If not multi-select, clear current selection
                    if (!isMultiSelect) {
                        this.clearSelection();
                    }
                    
                    // Toggle selection
                    if (this.selectedShips.includes(object)) {
                        if (isMultiSelect) {
                            this.deselectShip(object);
                        }
                    } else {
                        this.selectShip(object);
                    }
                    
                    // Stop after first ship is found
                    break;
                }
            }
            
            // If we have selected ships and didn't hit another ship, check for movement command
            if (this.selectedShips.length > 0 && !hitPlayerShip) {
                // Find intersection with the ground plane
                for (const intersect of intersects) {
                    if (intersect.object.userData && intersect.object.userData.isGround) {
                        // Move selected ships to this position
                        const targetPoint = intersect.point;
                        this.moveShipsTo(targetPoint);
                        return;
                    }
                }
            }
        }
        
        onMouseUp(event) {
            // We use onMouseDown for both selection and movement now
        }
        
        // Select a ship
        selectShip(ship) {
            if (!this.selectedShips.includes(ship)) {
                this.selectedShips.push(ship);
                
                // Show selection ring
                ship.children.forEach(child => {
                    if (child.userData && child.userData.isSelectionIndicator) {
                        child.visible = true;
                    }
                });
                
                console.log(`Selected ship: ${ship.userData.id}`);
            }
        }
        
        // Deselect a ship
        deselectShip(ship) {
            const index = this.selectedShips.indexOf(ship);
            if (index !== -1) {
                this.selectedShips.splice(index, 1);
                
                // Hide selection ring
                ship.children.forEach(child => {
                    if (child.userData && child.userData.isSelectionIndicator) {
                        child.visible = false;
                    }
                });
                
                console.log(`Deselected ship: ${ship.userData.id}`);
            }
        }
        
        // Clear all selections
        clearSelection() {
            while (this.selectedShips.length > 0) {
                this.deselectShip(this.selectedShips[0]);
            }
        }
        
        // Move selected ships to target position
        moveShipsTo(targetPoint) {
            // Can't move if no ships selected
            if (this.selectedShips.length === 0) return;
            
            // Calculate formation positions for all selected ships
            const positions = this.calculateFormationPositions(
                targetPoint,
                this.selectedShips.length
            );
            
            // Assign each ship a position and start moving
            this.selectedShips.forEach((ship, index) => {
                const position = positions[index];
                
                // Skip if this is somehow not a player ship or it's a defense platform
                if (!ship.userData.isPlayerShip || ship.userData.type === 'defense') return;
                
                // Set movement parameters
                ship.userData.isMoving = true;
                ship.userData.targetPosition = position.clone();
                
                // Calculate direction facing target
                const direction = new THREE.Vector3()
                    .subVectors(position, ship.position)
                    .normalize();
                
                // Calculate rotation to face movement direction
                ship.userData.targetRotation = Math.atan2(direction.x, direction.z);
                
                // Send move command to server for opponent to see
                if (socket) {
                    // Create movement data
                    const moveData = {
                        battle_room: this.battleRoom,
                        ship_id: ship.userData.id,
                        position: {
                            x: position.x,
                            y: position.y,
                            z: position.z
                        }
                    };
                    
                    // Send movement to server
                    socket.emit('ship_move', moveData);
                    
                    console.log(`Sent move command for ship ${ship.userData.id}:`, moveData);
                } else {
                    console.error('Socket not available for sending movement data');
                }
            });
        }
        
        // Calculate formation positions for ships
        calculateFormationPositions(centerPosition, shipCount) {
            const positions = [];
            
            // Use a simple grid formation
            const gridSize = Math.ceil(Math.sqrt(shipCount)); // number of ships per row/column
            const spacing = 15; // space between ships
            
            // Calculate the offset to center the formation
            const startX = centerPosition.x - (spacing * (gridSize - 1)) / 2;
            const startZ = centerPosition.z - (spacing * (gridSize - 1)) / 2;
            
            // Generate positions in a grid
            for (let i = 0; i < shipCount; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                
                positions.push(new THREE.Vector3(
                    startX + col * spacing,
                    centerPosition.y, // maintain same y-position
                    startZ + row * spacing
                ));
            }
            
            return positions;
        }
        
        // Handle opponent ship movements received from server
        handleOpponentMove(data) {
            console.log('Handling opponent move:', data);
            console.log('My user ID:', window.USER_INFO.id);
            console.log('Opponent ID:', this.opponentId);
            console.log('Available opponent ships:', this.opponentShips.map(s => s.userData.id));
            console.log('Looking for ship ID:', data.ship_id);
            
            // CRITICAL FIX: Check if the message is about our own ships, in which case ignore it
            // Parse the ship ID to extract the user ID - "player_USERID_TYPE_INDEX"
            const idParts = data.ship_id.split('_');
            if (idParts.length >= 2) {
                const shipUserId = idParts[1];
                
                // If this is a message about our own ship movement, ignore it
                // This prevents duplicate handling of our own ships
                if (shipUserId === window.USER_INFO.id.toString()) {
                    console.log('Ignoring movement of our own ship:', data.ship_id);
                    return;
                }
            }
            
            // Now we know this is an opponent ship, so look for it in our opponent ships list
            // Find the opponent ship with the matching ID
            let ship = this.opponentShips.find(ship => ship.userData.id === data.ship_id);
            
            // If we can't find by exact ID, try a more flexible approach
            if (!ship) {
                // Try to find by type and index regardless of the player ID part
                const match = data.ship_id.match(/player_\d+_(\w+)_(\d+)/);
                if (match) {
                    const [_, type, index] = match;
                    
                    // Look for any opponent ship with matching type and index
                    ship = this.opponentShips.find(s => 
                        s.userData.type === type && 
                        s.userData.id.endsWith(`_${index}`)
                    );
                    
                    if (ship) {
                        console.log(`Found ship by type and index: ${ship.userData.id}`);
                    }
                }
            }
            
            // If we still can't find the ship, warn and exit
            if (!ship) {
                console.warn(`Opponent ship ${data.ship_id} not found for movement command`);
                return;
            }
            
            // Create target position from data
            const targetPosition = new THREE.Vector3(
                data.position.x, 
                data.position.y, 
                data.position.z
            );
            
            console.log(`Moving opponent ship ${ship.userData.id} to:`, targetPosition);
            
            // Set movement parameters
            ship.userData.isMoving = true;
            ship.userData.targetPosition = targetPosition;
            
            // Calculate direction facing target
            const direction = new THREE.Vector3()
                .subVectors(targetPosition, ship.position)
                .normalize();
            
            // Calculate rotation to face movement direction
            ship.userData.targetRotation = Math.atan2(direction.x, direction.z);
        }
        
        // Select all player ships
        selectAllShips() {
            // Clear current selection
            this.clearSelection();
            
            // Select all player ships
            for (const ship of this.ships) {
                this.selectShip(ship);
            }
            
            console.log(`Selected all ${this.ships.length} ships`);
        }
        
        // Set attack mode
        setAttackMode(enabled) {
            this.isAttackMode = enabled;
            this.isPatrolMode = false;
            
            // Update UI button colors
            document.getElementById('attack-mode').style.backgroundColor = 
                enabled ? 'rgba(255, 100, 0, 0.8)' : 'rgba(200, 60, 0, 0.8)';
            document.getElementById('patrol-mode').style.backgroundColor = 'rgba(0, 80, 160, 0.8)';
            
            console.log(`Attack mode ${enabled ? 'enabled' : 'disabled'}`);
        }
        
        // Set patrol mode
        setPatrolMode(enabled) {
            this.isPatrolMode = enabled;
            this.isAttackMode = false;
            
            // Update UI button colors
            document.getElementById('patrol-mode').style.backgroundColor = 
                enabled ? 'rgba(0, 255, 100, 0.8)' : 'rgba(0, 80, 160, 0.8)';
            document.getElementById('attack-mode').style.backgroundColor = 'rgba(200, 60, 0, 0.8)';
            
            console.log(`Patrol mode ${enabled ? 'enabled' : 'disabled'}`);
        }
        
        // Retreat all ships to starting area
        retreat() {
            // Create retreat target position near starting area
            const retreatPosition = new THREE.Vector3(-200, 10, 0);
            
            // Move selected ships to retreat position
            this.moveShipsTo(retreatPosition);
            
            console.log(`Retreating ${this.selectedShips.length} ships`);
        }
        
        // Ship count updates
        updateShipCounts() {
            // Count ship types
            const fighters = this.ships.filter(ship => ship.userData.type === 'fighter').length;
            const capitals = this.ships.filter(ship => ship.userData.type === 'capital').length;
            
            // Update UI
            const fightersElement = document.getElementById('fighters-value');
            const capitalsElement = document.getElementById('capital-ships-value');
            
            if (fightersElement) fightersElement.textContent = fighters;
            if (capitalsElement) capitalsElement.textContent = capitals;
        }
        
        // Main animation loop
        animate() {
            requestAnimationFrame(this.animate.bind(this));
            
            // Get delta time for animations
            const delta = this.clock.getDelta() * 1000;
            
            // Update player ships
            this.ships.forEach(ship => {
                // Update movement if ship is moving
                if (ship.userData.isMoving && ship.userData.targetPosition) {
                    // Calculate distance to target
                    const targetPos = ship.userData.targetPosition;
                    const distance = ship.position.distanceTo(targetPos);
                    
                    // If close enough to target, stop moving
                    if (distance < 1) {
                        ship.userData.isMoving = false;
                        ship.userData.targetPosition = null;
                    } else {
                        // Move towards target at ship's speed
                        const moveSpeed = ship.userData.speed * (delta / 1000) * 30; // Scale by delta time
                        const direction = new THREE.Vector3()
                            .subVectors(targetPos, ship.position)
                            .normalize();
                        
                        // Apply movement
                        ship.position.add(direction.multiplyScalar(moveSpeed));
                        
                        // Smoothly rotate ship to face movement direction
                        if (ship.userData.targetRotation !== undefined) {
                            // Interpolate towards target rotation
                            const currentRotation = ship.rotation.y;
                            let targetRotation = ship.userData.targetRotation;
                            
                            // Normalize angle difference
                            let angleDiff = targetRotation - currentRotation;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            // Apply rotation with smooth damping
                            ship.rotation.y += angleDiff * 0.1;
                        }
                    }
                } else {
                    // Small idle rotation when not moving
                    ship.rotation.y += 0.0005;
                }
            });
            
            // Update opponent ships
            this.opponentShips.forEach(ship => {
                // Update movement if ship is moving
                if (ship.userData.isMoving && ship.userData.targetPosition) {
                    // Calculate distance to target
                    const targetPos = ship.userData.targetPosition;
                    const distance = ship.position.distanceTo(targetPos);
                    
                    // If close enough to target, stop moving
                    if (distance < 1) {
                        ship.userData.isMoving = false;
                        ship.userData.targetPosition = null;
                    } else {
                        // Move towards target at ship's speed
                        const moveSpeed = ship.userData.speed * (delta / 1000) * 30; // Scale by delta time
                        const direction = new THREE.Vector3()
                            .subVectors(targetPos, ship.position)
                            .normalize();
                        
                        // Apply movement
                        ship.position.add(direction.multiplyScalar(moveSpeed));
                        
                        // Smoothly rotate ship to face movement direction
                        if (ship.userData.targetRotation !== undefined) {
                            // Interpolate towards target rotation
                            const currentRotation = ship.rotation.y;
                            let targetRotation = ship.userData.targetRotation;
                            
                            // Normalize angle difference
                            let angleDiff = targetRotation - currentRotation;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            // Apply rotation with smooth damping
                            ship.rotation.y += angleDiff * 0.1;
                        }
                    }
                } else {
                    // Small idle rotation when not moving
                    ship.rotation.y += 0.0005;
                }
            });
            
            // Render scene
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    // Initialize combat game function - called from battle_accepted event
    function initializeCombatGame(data) {
        console.log("Initializing combat game with data:", data);
        console.log("THREE.js version:", THREE.REVISION);
        
        try {
            // Create combat game instance
            window.combatGame = new CombatGame(data);
            console.log("Combat game initialized successfully");
            return window.combatGame;
        } catch (error) {
            console.error("Error in initializeCombatGame:", error);
            alert("An error occurred initializing the combat game: " + error.message);
            return null;
        }
    }
</script>
{% endblock %}