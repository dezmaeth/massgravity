{% extends "base.html" %}

{% block title %}Play Game{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/space-animations.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/game.css')}}">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<!-- Socket.IO Client -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.js"></script>
{% endblock %}

{% block content %}
<!-- Space background -->
<div class="space-background">
    <div class="nebula-background"></div>
    <div class="stars"></div>
    <div class="stars"></div>
</div>

<div id="loading-screen" class="loading-screen">
    <h2>Loading Mass Gravity</h2>
    <div class="progress">
        <div id="progress-bar" class="progress-bar"></div>
    </div>
</div>

<div id="resource-display" class="breathing-panel">
    <div class="resource-item">
        <i class="fas fa-coins pulse-glow"></i>
        <span id="resources-value">0</span> Resources
    </div>
    <div class="resource-item">
        <i class="fas fa-flask pulse-glow"></i>
        <span id="research-points-value">0</span> Research
    </div>
    <div class="resource-item">
        <i class="fas fa-users pulse-glow"></i>
        <span id="population-value">0</span> Population
    </div>
    <div class="resource-item faction-blue">
        <i class="fas fa-gem"></i>
        <span id="blue-material-value">0</span>
    </div>
    <div class="resource-item faction-red">
        <i class="fas fa-gem"></i>
        <span id="red-material-value">0</span>
    </div>
    <div class="resource-item faction-green">
        <i class="fas fa-gem"></i>
        <span id="green-material-value">0</span>
    </div>
    
    <!-- Audio Controls -->
    <div id="audio-controls">
        <span class="track-name" id="track-name">No track playing</span>
        <button id="play-pause-btn" class="audio-control-button">
            <i class="fas fa-play" id="play-icon"></i>
        </button>
        <button id="next-track-btn" class="audio-control-button">
            <i class="fas fa-forward"></i>
        </button>
        <button id="mute-btn" class="audio-control-button">
            <i class="fas fa-volume-up" id="volume-icon"></i>
        </button>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    
    <a href="{{ url_for('auth.logout') }}" class="resource-item logout-button">
        <i class="fas fa-sign-out-alt"></i> Logout
    </a>
</div>

<div id="game-container"></div>

<!-- Build Menu (outside the UI overlay to fix z-index issues) -->
<div id="build-menu" style="display: none;" class="holographic-panel scanning-panel">
    <h3>Build Structures</h3>
    <div class="build-menu-content">
        <!-- Structure items go here -->
    </div>
</div>

<div id="ui-overlay">
    <!-- Other UI elements can go here -->
</div>

<!-- Players list panel -->
<div id="players-panel" class="holographic-panel scanning-panel" style="position: fixed; top: 70px; right: 20px; width: 250px; background-color: rgba(0, 20, 40, 0.8); border: 1px solid rgba(0, 100, 255, 0.5); color: #a0e0ff; padding: 15px; border-radius: 5px; display: none; backdrop-filter: blur(5px);">
    <h3 style="margin-top: 0; color: #00ccff; border-bottom: 1px solid rgba(0, 100, 255, 0.5); padding-bottom: 8px; margin-bottom: 10px;">Online Players</h3>
    <div id="players-list" style="max-height: 300px; overflow-y: auto;">
        <div class="no-players" style="text-align: center; padding: 20px 0; color: rgba(255, 255, 255, 0.6);">
            No other players online
        </div>
    </div>
    <button id="refresh-players" style="width: 100%; margin-top: 10px; background: rgba(0, 80, 160, 0.8); color: #a0e0ff; border: 1px solid rgba(0, 150, 255, 0.5); padding: 8px; cursor: pointer; border-radius: 3px;">
        <i class="fas fa-sync-alt"></i> Refresh
    </button>
</div>

<!-- Battle request modal -->
<div id="battle-request-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 2000;">
    <div class="modal-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 30, 60, 0.95); border: 2px solid rgba(0, 100, 255, 0.7); border-radius: 8px; padding: 20px; min-width: 300px; box-shadow: 0 0 30px rgba(0, 150, 255, 0.5); text-align: center;">
        <h3 style="color: #00ccff; margin-top: 0;">Battle Request</h3>
        <p id="battle-request-text" style="margin-bottom: 20px;">Player wants to battle with you!</p>
        <div style="display: flex; justify-content: space-between; gap: 10px;">
            <button id="accept-battle" style="flex: 1; background-color: rgba(46, 204, 113, 0.8); color: white; border: none; padding: 10px; cursor: pointer; border-radius: 3px;">
                Accept
            </button>
            <button id="decline-battle" style="flex: 1; background-color: rgba(231, 76, 60, 0.8); color: white; border: none; padding: 10px; cursor: pointer; border-radius: 3px;">
                Decline
            </button>
        </div>
    </div>
</div>

<!-- Player list toggle button -->
<button id="toggle-players-panel" style="position: fixed; top: 70px; right: 20px; background-color: rgba(0, 80, 160, 0.8); color: #a0e0ff; border: 1px solid rgba(0, 150, 255, 0.5); padding: 8px 12px; border-radius: 5px; cursor: pointer; z-index: 1000;">
    <i class="fas fa-users"></i> Players
</button>

<!-- Connection status indicator -->
<div id="connection-status" class="connecting">
    <div class="indicator"></div>
    <span>Connecting...</span>
</div>

{% endblock %}

{% block scripts %}
<script>
    // Store user info for the game
    window.USER_INFO = {
        id: {{ current_user.id }},
        username: "{{ current_user.username }}",
        faction: "{{ current_user.faction }}"
    };
    
    // Set up Socket.IO connection
    const socket = io();
    
    // Store battle request info
    let currentBattleRequest = null;
    
    // Connection status handlers
    socket.on('connect', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'connected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Connected</span>';
        console.log('Socket connected');
        
        // Request active players list
        socket.emit('get_active_players');
    });
    
    socket.on('disconnect', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'disconnected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Disconnected</span>';
        console.log('Socket disconnected');
    });
    
    socket.on('connect_error', function() {
        const statusDiv = document.getElementById('connection-status');
        statusDiv.className = 'disconnected';
        statusDiv.innerHTML = '<div class="indicator"></div><span>Connection Error</span>';
        console.log('Socket connection error');
    });
    
    // Players list functionality
    socket.on('active_players_list', function(data) {
        updatePlayersList(data.players);
    });
    
    // Battle request handlers
    socket.on('battle_request', function(data) {
        // Store request data
        currentBattleRequest = data;
        
        // Update the request text
        document.getElementById('battle-request-text').textContent = 
            `${data.from_name} (${data.from_faction}) wants to battle with you!`;
        
        // Show the modal
        document.getElementById('battle-request-modal').style.display = 'block';
    });
    
    socket.on('battle_request_sent', function(data) {
        showNotification(`Battle request sent to ${data.target_name}`);
    });
    
    socket.on('battle_request_error', function(data) {
        showNotification(data.message, 'error');
    });
    
    socket.on('battle_accepted', function(data) {
        showNotification(`${data.opponent_name} accepted your battle request!`);
        // Redirect to combat page
        window.location.href = `/combat/${data.opponent_id}`;
    });
    
    socket.on('battle_declined', function(data) {
        showNotification(`${data.opponent_name} declined your battle request.`, 'error');
    });
    
    socket.on('battle_response_error', function(data) {
        showNotification(data.message, 'error');
    });
    
    // Players panel toggle
    document.getElementById('toggle-players-panel').addEventListener('click', function() {
        const panel = document.getElementById('players-panel');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
            // Request updated player list
            socket.emit('get_active_players');
        } else {
            panel.style.display = 'none';
        }
    });
    
    // Battle request modal response buttons
    document.getElementById('accept-battle').addEventListener('click', function() {
        if (currentBattleRequest) {
            socket.emit('accept_battle', {
                requester_id: currentBattleRequest.from_id
            });
            document.getElementById('battle-request-modal').style.display = 'none';
        }
    });
    
    document.getElementById('decline-battle').addEventListener('click', function() {
        if (currentBattleRequest) {
            socket.emit('decline_battle', {
                requester_id: currentBattleRequest.from_id
            });
            document.getElementById('battle-request-modal').style.display = 'none';
            currentBattleRequest = null;
        }
    });
    
    // Refresh players list button
    document.getElementById('refresh-players').addEventListener('click', function() {
        socket.emit('get_active_players');
    });
    
    // Function to update the players list
    function updatePlayersList(players) {
        const playersList = document.getElementById('players-list');
        
        if (players.length === 0) {
            playersList.innerHTML = '<div class="no-players" style="text-align: center; padding: 20px 0; color: rgba(255, 255, 255, 0.6);">No other players online</div>';
            return;
        }
        
        // Clear the list
        playersList.innerHTML = '';
        
        // Add each player
        players.forEach(player => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.style.display = 'flex';
            playerItem.style.justifyContent = 'space-between';
            playerItem.style.alignItems = 'center';
            playerItem.style.padding = '8px';
            playerItem.style.marginBottom = '5px';
            playerItem.style.background = 'rgba(0, 50, 100, 0.3)';
            playerItem.style.borderRadius = '3px';
            playerItem.style.border = '1px solid rgba(0, 100, 255, 0.3)';
            
            // Assign faction color
            let factionColor = '#3498db'; // Blue default
            if (player.faction === 'red') {
                factionColor = '#e74c3c';
            } else if (player.faction === 'green') {
                factionColor = '#2ecc71';
            }
            
            playerItem.innerHTML = `
                <div style="display: flex; align-items: center;">
                    <div style="width: 10px; height: 10px; background-color: ${factionColor}; border-radius: 50%; margin-right: 8px;"></div>
                    <span>${player.username}</span>
                </div>
                <button class="attack-button" data-player-id="${player.id}" data-player-name="${player.username}" data-player-faction="${player.faction}"
                    style="background: rgba(200, 60, 60, 0.7); color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                    Attack
                </button>
            `;
            
            playersList.appendChild(playerItem);
        });
        
        // Add event listeners to attack buttons
        const attackButtons = playersList.querySelectorAll('.attack-button');
        attackButtons.forEach(button => {
            button.addEventListener('click', function() {
                const playerId = this.getAttribute('data-player-id');
                const playerName = this.getAttribute('data-player-name');
                
                // Send battle request
                socket.emit('request_battle', {
                    target_id: parseInt(playerId)
                });
                
                showNotification(`Sending battle request to ${playerName}...`);
            });
        });
    }
    
    // Resource update handler from server
    socket.on('resource_update', function(data) {
        console.log('Resource update received:', data);
        
        // Update game state with server data
        if (window.gameState) {
            // Update resources
            window.gameState.resources = data.resources;
            
            // Update materials
            if (data.materials && window.gameState.materials) {
                window.gameState.materials.blue = data.materials.blue;
                window.gameState.materials.red = data.materials.red;
                window.gameState.materials.green = data.materials.green;
            }
            
            // Update ships
            if (data.ships && window.gameState.ships) {
                window.gameState.ships.fighters = data.ships.fighters;
                window.gameState.ships.capital_ships = data.ships.capital_ships;
            }
            
            // Call update function if game is loaded
            if (window.massGravity) {
                window.massGravity.updateResourceDisplay();
            } else {
                // Directly update DOM elements if game isn't loaded yet
                updateDOMResourceDisplay(data);
            }
        }
    });
    
    // Save game response handler
    socket.on('save_success', function(response) {
        console.log('Save success:', response);
        
        if (response.updated_data) {
            // Update game state with returned data
            if (window.gameState) {
                // Update game state with server data
                Object.assign(window.gameState, response.updated_data);
                
                // Call update function if game is loaded
                if (window.massGravity) {
                    window.massGravity.updateResourceDisplay();
                }
            }
        }
        
        // Show success notification
        showNotification('Game saved successfully');
    });
    
    socket.on('save_error', function(response) {
        console.error('Save error:', response);
        showNotification('Error saving game: ' + response.message, 'error');
    });
    
    // Utility function to update resource display DOM elements directly with animation
    function updateDOMResourceDisplay(data) {
        // Helper function to animate value changes
        function animateValueChange(element, newValue) {
            if (!element) return;
            
            // Get current value
            const currentValue = parseInt(element.textContent) || 0;
            newValue = Math.floor(newValue);
            
            // If value changed, animate
            if (currentValue !== newValue) {
                // Add animation class
                element.classList.add('resource-increment');
                
                // Set the new value
                element.textContent = newValue;
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    element.classList.remove('resource-increment');
                }, 500);
            }
        }
        
        // Update resources
        const resourcesValue = document.getElementById('resources-value');
        if (resourcesValue && typeof data.resources !== 'undefined') {
            animateValueChange(resourcesValue, data.resources);
        }
        
        // Update research points
        const researchPointsValue = document.getElementById('research-points-value');
        if (researchPointsValue && typeof data.research_points !== 'undefined') {
            animateValueChange(researchPointsValue, data.research_points);
        }
        
        // Update population
        const populationValue = document.getElementById('population-value');
        if (populationValue && typeof data.population !== 'undefined') {
            animateValueChange(populationValue, data.population);
        }
        
        // Update faction materials
        if (data.materials) {
            // Blue materials
            const blueMaterial = document.getElementById('blue-material-value');
            if (blueMaterial && typeof data.materials.blue !== 'undefined') {
                animateValueChange(blueMaterial, data.materials.blue);
            }
            
            // Red materials
            const redMaterial = document.getElementById('red-material-value');
            if (redMaterial && typeof data.materials.red !== 'undefined') {
                animateValueChange(redMaterial, data.materials.red);
            }
            
            // Green materials
            const greenMaterial = document.getElementById('green-material-value');
            if (greenMaterial && typeof data.materials.green !== 'undefined') {
                animateValueChange(greenMaterial, data.materials.green);
            }
        }
    }
    
    // Utility function to show notifications with animation
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = 'notification ' + (type === 'error' ? 'error space-alert' : '');
        
        // Add icon based on notification type
        const icon = type === 'error' ? 
            '<i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>' : 
            '<i class="fas fa-info-circle" style="margin-right: 8px;"></i>';
            
        notification.innerHTML = icon + message;
        
        // Set background color based on type
        if (type === 'error') {
            notification.style.backgroundColor = 'rgba(231, 76, 60, 0.8)';
            notification.style.borderColor = 'rgba(231, 76, 60, 0.9)';
        } else {
            notification.style.backgroundColor = 'rgba(46, 204, 113, 0.8)';
            notification.style.borderColor = 'rgba(46, 204, 113, 0.9)';
        }
        
        document.body.appendChild(notification);
        
        // Add staggered animation class
        notification.classList.add('fade-in-up');
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px) translateX(-50%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 3000);
    }
    
    // Set up the build menu
    document.addEventListener('DOMContentLoaded', function() {
        const buildMenu = document.getElementById('build-menu');
        const buildMenuContent = document.querySelector('.build-menu-content');
        
        // Only show the build menu when clicking on a planet
        buildMenu.style.display = 'none';
        
        // Define building options
        const buildOptions = [
            {
                type: 'mining',
                name: 'Mining Station',
                desc: 'Extracts minerals from the planet',
                cost: 100,
                icon: 'M',
                iconColor: 'rgba(255, 200, 0, 0.5)'
            },
            {
                type: 'research',
                name: 'Research Outpost',
                desc: 'Generates research points',
                cost: 150,
                icon: 'R',
                iconColor: 'rgba(0, 200, 255, 0.5)'
            },
            {
                type: 'colony',
                name: 'Colony Base',
                desc: 'Allows population growth',
                cost: 200,
                icon: 'C',
                iconColor: 'rgba(0, 255, 100, 0.5)'
            },
            {
                type: 'defense',
                name: 'Defense Platform',
                desc: 'Defends against enemy attacks',
                cost: 180,
                icon: 'D',
                iconColor: 'rgba(255, 50, 0, 0.5)'
            },
            {
                type: 'fighter_hangar',
                name: 'Fighter Hangar',
                desc: 'Allows construction of fighter ships',
                cost: 500,
                icon: 'F',
                iconColor: 'rgba(100, 150, 255, 0.5)'
            },
            {
                type: 'shipyard',
                name: 'Capital Shipyard',
                desc: 'Allows construction of capital ships',
                cost: 1000,
                icon: 'S',
                iconColor: 'rgba(200, 100, 255, 0.5)'
            }
        ];
        
        // Generate menu HTML
        function updateBuildMenu(resources = 500) {
            let html = '';
            
            buildOptions.forEach(option => {
                const canAfford = resources >= option.cost;
                const itemClass = canAfford ? 'build-menu-item' : 'build-menu-item disabled';
                const costClass = canAfford ? 'build-menu-item-cost' : 'build-menu-item-cost insufficient';
                
                html += `
                    <div class="${itemClass}" data-type="${option.type}" data-cost="${option.cost}">
                        <div class="build-menu-item-icon" style="background-color: ${option.iconColor};">${option.icon}</div>
                        <div class="build-menu-item-details">
                            <div class="build-menu-item-name">${option.name}</div>
                            <div class="build-menu-item-desc">${option.desc}</div>
                            <div class="${costClass}">Cost: ${option.cost} resources</div>
                        </div>
                    </div>
                `;
            });
            
            buildMenuContent.innerHTML = html;
            
            // Add click handlers
            buildMenuContent.querySelectorAll('.build-menu-item').forEach(item => {
                item.addEventListener('click', function() {
                    const type = this.getAttribute('data-type');
                    const cost = parseInt(this.getAttribute('data-cost'));
                    
                    if (this.classList.contains('disabled')) {
                        showNotification(`Not enough resources to build ${type} station.`);
                        return;
                    }
                    
                    // The game will handle this through the event listener
                    const buildEvent = new CustomEvent('build-structure', {
                        detail: { type, cost }
                    });
                    document.dispatchEvent(buildEvent);
                });
            });
        }
        
        // Generate initial menu content
        updateBuildMenu();
        
        // Export build menu functions to window object
        window.buildMenuUI = {
            show: function() {
                buildMenu.style.display = 'block';
            },
            hide: function() {
                buildMenu.style.display = 'none';
            },
            update: updateBuildMenu
        };
    });
</script>

<!-- Import Three.js from CDN -->
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
}
</script>

<!-- Load the modules using original script tags -->
<script type="module" src="{{ url_for('static', filename='js/game.js') }}"></script>
<script type="module" src="{{ url_for('static', filename='js/render.js') }}"></script>

<!-- Initialize game -->
<script>
    // Wait for everything to load then create the Render instance
    window.addEventListener('load', () => {
        // By now all modules should be loaded
        if (window.Render) {
            const game = new window.Render();
            window.massGravity = game;
            game.render();
            console.log("Render initialized successfully");
        } else {
            console.error("Render class not found. Check module loading.");
        }
        
        // Initialize audio system
        initAudioSystem();
    });
    
    // Audio system initialization
    function initAudioSystem() {
        // Create debug info first
        console.log("Initializing audio system");
        
        // Stop any existing background music from game.js
        stopExistingBackgroundMusic();
        
        // Available tracks
        const tracks = [
            { 
                name: "Main Theme", 
                path: "{{ url_for('static', filename='assets/music/home.mp3') }}" 
            },
            { 
                name: "Space Exploration", 
                path: "{{ url_for('static', filename='assets/music/track01.mp3') }}" 
            }
        ];
        
        console.log("Audio tracks defined:", tracks);
        
        // Function to stop any existing background music
        function stopExistingBackgroundMusic() {
            // If the game has its own background music playing, stop it
            if (window.massGravity && window.massGravity.backgroundMusic) {
                console.log("Stopping existing background music from game.js");
                try {
                    window.massGravity.backgroundMusic.pause();
                    window.massGravity.backgroundMusic.currentTime = 0;
                    window.massGravity.isMusicMuted = true;
                    
                    // Clear any fade interval
                    if (window.massGravity.fadeInInterval) {
                        clearInterval(window.massGravity.fadeInInterval);
                        window.massGravity.fadeInInterval = null;
                    }
                } catch (e) {
                    console.warn("Error stopping existing music:", e);
                }
            }
        }
        
        // Audio elements and state
        let currentTrackIndex = 0;
        let audio = new Audio();
        let isPlaying = false;
        let isMuted = false;
        let volume = 0.7; // Default volume (70%)
        
        // Save audio preferences to localStorage
        function saveAudioPreferences() {
            localStorage.setItem('massGravity_volume', volume);
            localStorage.setItem('massGravity_muted', isMuted);
            localStorage.setItem('massGravity_lastTrack', currentTrackIndex);
        }
        
        // Load audio preferences from localStorage
        function loadAudioPreferences() {
            const savedVolume = localStorage.getItem('massGravity_volume');
            const savedMuted = localStorage.getItem('massGravity_muted');
            const savedTrack = localStorage.getItem('massGravity_lastTrack');
            
            if (savedVolume !== null) {
                volume = parseFloat(savedVolume);
                document.getElementById('volume-slider').value = volume * 100;
            }
            
            if (savedMuted !== null) {
                isMuted = savedMuted === 'true';
                updateMuteButton();
            }
            
            if (savedTrack !== null) {
                currentTrackIndex = parseInt(savedTrack);
                if (currentTrackIndex >= tracks.length) {
                    currentTrackIndex = 0;
                }
            }
        }
        
        // Load track and start playing
        function loadAndPlayTrack(index) {
            currentTrackIndex = index;
            
            // Create a new Audio element instead of reusing the old one
            // This helps avoid browser autoplay restrictions
            audio = new Audio(tracks[index].path);
            audio.volume = isMuted ? 0 : volume;
            
            // Update track name display
            document.getElementById('track-name').textContent = tracks[index].name;
            
            // Set up ended event to play next track
            audio.onended = function() {
                playNextTrack();
            };
            
            // Start playing with a deliberate user interaction context
            console.log("Attempting to play track:", tracks[index].name);
            
            // Force a small delay to ensure the audio element is properly initialized
            setTimeout(() => {
                const playPromise = audio.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log("Audio playback started successfully");
                            isPlaying = true;
                            updatePlayButton();
                            saveAudioPreferences();
                        })
                        .catch(error => {
                            console.error("Error playing audio:", error);
                            isPlaying = false;
                            updatePlayButton();
                            
                            // Show a notification about the autoplay issue
                            if (error.name === "NotAllowedError") {
                                showNotification("Autoplay blocked: Click play to start music", "error");
                            }
                        });
                }
            }, 100);
        }
        
        // Play/pause toggle
        function togglePlayPause() {
            console.log("Toggle play/pause, current state:", isPlaying);
            
            if (isPlaying) {
                console.log("Pausing audio");
                audio.pause();
                isPlaying = false;
            } else {
                console.log("Attempting to play audio");
                if (audio.src) {
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise
                            .then(() => {
                                console.log("Play resumed successfully");
                                isPlaying = true;
                            })
                            .catch(error => {
                                console.error("Error playing audio:", error);
                                // If there was a network error or the src is invalid, reload the track
                                if (error.name !== "NotAllowedError") {
                                    loadAndPlayTrack(currentTrackIndex);
                                    return;
                                }
                                isPlaying = false;
                            });
                    }
                } else {
                    console.log("No audio source, loading track");
                    loadAndPlayTrack(currentTrackIndex);
                }
            }
            updatePlayButton();
        }
        
        // Play next track
        function playNextTrack() {
            currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
            loadAndPlayTrack(currentTrackIndex);
        }
        
        // Toggle mute
        function toggleMute() {
            isMuted = !isMuted;
            audio.volume = isMuted ? 0 : volume;
            updateMuteButton();
            saveAudioPreferences();
        }
        
        // Set volume
        function setVolume(value) {
            volume = value / 100;
            if (!isMuted) {
                audio.volume = volume;
            }
            saveAudioPreferences();
        }
        
        // Update play/pause button UI
        function updatePlayButton() {
            const playIcon = document.getElementById('play-icon');
            if (isPlaying) {
                playIcon.className = 'fas fa-pause';
                document.getElementById('play-pause-btn').classList.add('active');
            } else {
                playIcon.className = 'fas fa-play';
                document.getElementById('play-pause-btn').classList.remove('active');
            }
        }
        
        // Update mute button UI
        function updateMuteButton() {
            const volumeIcon = document.getElementById('volume-icon');
            const muteBtn = document.getElementById('mute-btn');
            
            if (isMuted) {
                volumeIcon.className = 'fas fa-volume-mute';
                muteBtn.classList.add('muted');
            } else {
                if (volume > 0.5) {
                    volumeIcon.className = 'fas fa-volume-up';
                } else if (volume > 0) {
                    volumeIcon.className = 'fas fa-volume-down';
                } else {
                    volumeIcon.className = 'fas fa-volume-off';
                }
                muteBtn.classList.remove('muted');
            }
        }
        
        // Event listeners are now setup earlier
        
        // Add buttons event listeners first, before autoplay attempts
        document.getElementById('play-pause-btn').addEventListener('click', function(e) {
            // Use the click event to enable audio
            e.stopPropagation();
            console.log("Play/pause button clicked");
            togglePlayPause();
        });
        
        document.getElementById('next-track-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            console.log("Next track button clicked");
            playNextTrack();
        });
        
        document.getElementById('mute-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            console.log("Mute button clicked");
            toggleMute();
        });
        
        const volumeSlider = document.getElementById('volume-slider');
        volumeSlider.addEventListener('input', function() {
            console.log("Volume changed to:", this.value);
            setVolume(this.value);
        });
        
        // Initialize with saved preferences
        loadAudioPreferences();
        
        console.log("Audio system initialized, will play the first track immediately");
        
        // Start playing the first track immediately
        loadAndPlayTrack(currentTrackIndex);
        
        // Make sure the track name is shown
        document.getElementById('track-name').textContent = tracks[currentTrackIndex].name;
        
        // Expose audio control functions to window
        window.audioControls = {
            play: function() {
                if (!isPlaying) togglePlayPause();
            },
            pause: function() {
                if (isPlaying) togglePlayPause();
            },
            next: playNextTrack,
            mute: function() {
                if (!isMuted) toggleMute();
            },
            unmute: function() {
                if (isMuted) toggleMute();
            },
            setVolume: setVolume,
            getCurrentTrack: function() {
                return tracks[currentTrackIndex]?.name || 'None';
            }
        };
    }
</script>
{% endblock %}